// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: calculator.capnp

#ifndef CAPNP_INCLUDED_85150b117366d14b_
#define CAPNP_INCLUDED_85150b117366d14b_

#include <capnp/generated-header-support.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#if CAPNP_VERSION != 5003
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(97983392df35cc36);
CAPNP_DECLARE_SCHEMA(d438d7caf5548d15);
CAPNP_DECLARE_SCHEMA(d99522a3d3878d66);
CAPNP_DECLARE_SCHEMA(c3e69d34d3ee48d2);
CAPNP_DECLARE_SCHEMA(d3532574d58db558);
CAPNP_DECLARE_SCHEMA(e6be6723122ae822);
CAPNP_DECLARE_SCHEMA(ede83a3d96840394);
CAPNP_DECLARE_SCHEMA(b19160df70b87717);
CAPNP_DECLARE_SCHEMA(c0e0abf76914dead);
CAPNP_DECLARE_SCHEMA(8793407861e6dfe6);
enum class Operator_8793407861e6dfe6: uint16_t {
  ADD,
  SUBTRACT,
  MULTIPLY,
  DIVIDE,
};
CAPNP_DECLARE_ENUM(Operator, 8793407861e6dfe6);
CAPNP_DECLARE_SCHEMA(bb0eaae1557a36d4);
CAPNP_DECLARE_SCHEMA(81b1a3f55887a611);
CAPNP_DECLARE_SCHEMA(f287bcba4556dc89);
CAPNP_DECLARE_SCHEMA(8d24f465047cd6c8);
CAPNP_DECLARE_SCHEMA(8a8dceb4f4a3c530);
CAPNP_DECLARE_SCHEMA(d18fbb7763c08c20);

}  // namespace schemas
}  // namespace capnp


struct Calculator {
  Calculator() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Expression;
  struct Value;
  struct Function;
  typedef ::capnp::schemas::Operator_8793407861e6dfe6 Operator;

  struct EvaluateParams;
  struct EvaluateResults;
  struct DefFunctionParams;
  struct DefFunctionResults;
  struct GetOperatorParams;
  struct GetOperatorResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(97983392df35cc36)
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
  };
  #endif  // !CAPNP_LITE
};

struct Calculator::Expression {
  Expression() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    LITERAL,
    PREVIOUS_RESULT,
    PARAMETER,
    CALL,
  };
  struct Call;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d438d7caf5548d15, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Calculator::Expression::Call {
  Call() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d99522a3d3878d66, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Calculator::Value {
  Value() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct ReadParams;
  struct ReadResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(c3e69d34d3ee48d2)
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
  };
  #endif  // !CAPNP_LITE
};

struct Calculator::Value::ReadParams {
  ReadParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d3532574d58db558, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Calculator::Value::ReadResults {
  ReadResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e6be6723122ae822, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Calculator::Function {
  Function() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct CallParams;
  struct CallResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(ede83a3d96840394)
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
  };
  #endif  // !CAPNP_LITE
};

struct Calculator::Function::CallParams {
  CallParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b19160df70b87717, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Calculator::Function::CallResults {
  CallResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c0e0abf76914dead, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Calculator::EvaluateParams {
  EvaluateParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bb0eaae1557a36d4, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Calculator::EvaluateResults {
  EvaluateResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(81b1a3f55887a611, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Calculator::DefFunctionParams {
  DefFunctionParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f287bcba4556dc89, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Calculator::DefFunctionResults {
  DefFunctionResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8d24f465047cd6c8, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Calculator::GetOperatorParams {
  GetOperatorParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8a8dceb4f4a3c530, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Calculator::GetOperatorResults {
  GetOperatorResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d18fbb7763c08c20, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

#if !CAPNP_LITE
class Calculator::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Calculator Calls;
  typedef Calculator Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::Calculator::EvaluateParams,  ::Calculator::EvaluateResults> evaluateRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::Calculator::DefFunctionParams,  ::Calculator::DefFunctionResults> defFunctionRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::Calculator::GetOperatorParams,  ::Calculator::GetOperatorResults> getOperatorRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Calculator::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Calculator Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::Calculator::EvaluateParams EvaluateParams;
  typedef  ::Calculator::EvaluateResults EvaluateResults;
  typedef ::capnp::CallContext<EvaluateParams, EvaluateResults> EvaluateContext;
  virtual ::kj::Promise<void> evaluate(EvaluateContext context);
  typedef  ::Calculator::DefFunctionParams DefFunctionParams;
  typedef  ::Calculator::DefFunctionResults DefFunctionResults;
  typedef ::capnp::CallContext<DefFunctionParams, DefFunctionResults> DefFunctionContext;
  virtual ::kj::Promise<void> defFunction(DefFunctionContext context);
  typedef  ::Calculator::GetOperatorParams GetOperatorParams;
  typedef  ::Calculator::GetOperatorResults GetOperatorResults;
  typedef ::capnp::CallContext<GetOperatorParams, GetOperatorResults> GetOperatorContext;
  virtual ::kj::Promise<void> getOperator(GetOperatorContext context);

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Calculator::Expression::Reader {
public:
  typedef Expression Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isLiteral() const;
  inline double getLiteral() const;

  inline bool isPreviousResult() const;
  inline bool hasPreviousResult() const;
#if !CAPNP_LITE
  inline  ::Calculator::Value::Client getPreviousResult() const;
#endif  // !CAPNP_LITE

  inline bool isParameter() const;
  inline  ::uint32_t getParameter() const;

  inline bool isCall() const;
  inline Call::Reader getCall() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Calculator::Expression::Builder {
public:
  typedef Expression Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isLiteral();
  inline double getLiteral();
  inline void setLiteral(double value);

  inline bool isPreviousResult();
  inline bool hasPreviousResult();
#if !CAPNP_LITE
  inline  ::Calculator::Value::Client getPreviousResult();
  inline void setPreviousResult( ::Calculator::Value::Client&& value);
  inline void setPreviousResult( ::Calculator::Value::Client& value);
  inline void adoptPreviousResult(::capnp::Orphan< ::Calculator::Value>&& value);
  inline ::capnp::Orphan< ::Calculator::Value> disownPreviousResult();
#endif  // !CAPNP_LITE

  inline bool isParameter();
  inline  ::uint32_t getParameter();
  inline void setParameter( ::uint32_t value);

  inline bool isCall();
  inline Call::Builder getCall();
  inline Call::Builder initCall();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Calculator::Expression::Pipeline {
public:
  typedef Expression Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Calculator::Expression::Call::Reader {
public:
  typedef Call Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasFunction() const;
#if !CAPNP_LITE
  inline  ::Calculator::Function::Client getFunction() const;
#endif  // !CAPNP_LITE

  inline bool hasParams() const;
  inline  ::capnp::List< ::Calculator::Expression>::Reader getParams() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Calculator::Expression::Call::Builder {
public:
  typedef Call Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasFunction();
#if !CAPNP_LITE
  inline  ::Calculator::Function::Client getFunction();
  inline void setFunction( ::Calculator::Function::Client&& value);
  inline void setFunction( ::Calculator::Function::Client& value);
  inline void adoptFunction(::capnp::Orphan< ::Calculator::Function>&& value);
  inline ::capnp::Orphan< ::Calculator::Function> disownFunction();
#endif  // !CAPNP_LITE

  inline bool hasParams();
  inline  ::capnp::List< ::Calculator::Expression>::Builder getParams();
  inline void setParams( ::capnp::List< ::Calculator::Expression>::Reader value);
  inline  ::capnp::List< ::Calculator::Expression>::Builder initParams(unsigned int size);
  inline void adoptParams(::capnp::Orphan< ::capnp::List< ::Calculator::Expression>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Calculator::Expression>> disownParams();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Calculator::Expression::Call::Pipeline {
public:
  typedef Call Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Calculator::Function::Client getFunction();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Calculator::Value::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Calculator::Value Calls;
  typedef Calculator::Value Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::Calculator::Value::ReadParams,  ::Calculator::Value::ReadResults> readRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Calculator::Value::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Calculator::Value Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::Calculator::Value::ReadParams ReadParams;
  typedef  ::Calculator::Value::ReadResults ReadResults;
  typedef ::capnp::CallContext<ReadParams, ReadResults> ReadContext;
  virtual ::kj::Promise<void> read(ReadContext context);

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Calculator::Value::ReadParams::Reader {
public:
  typedef ReadParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Calculator::Value::ReadParams::Builder {
public:
  typedef ReadParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Calculator::Value::ReadParams::Pipeline {
public:
  typedef ReadParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Calculator::Value::ReadResults::Reader {
public:
  typedef ReadResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline double getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Calculator::Value::ReadResults::Builder {
public:
  typedef ReadResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getValue();
  inline void setValue(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Calculator::Value::ReadResults::Pipeline {
public:
  typedef ReadResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Calculator::Function::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Calculator::Function Calls;
  typedef Calculator::Function Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::Calculator::Function::CallParams,  ::Calculator::Function::CallResults> callRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Calculator::Function::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Calculator::Function Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::Calculator::Function::CallParams CallParams;
  typedef  ::Calculator::Function::CallResults CallResults;
  typedef ::capnp::CallContext<CallParams, CallResults> CallContext;
  virtual ::kj::Promise<void> call(CallContext context);

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Calculator::Function::CallParams::Reader {
public:
  typedef CallParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasParams() const;
  inline  ::capnp::List<double>::Reader getParams() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Calculator::Function::CallParams::Builder {
public:
  typedef CallParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasParams();
  inline  ::capnp::List<double>::Builder getParams();
  inline void setParams( ::capnp::List<double>::Reader value);
  inline void setParams(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double>::Builder initParams(unsigned int size);
  inline void adoptParams(::capnp::Orphan< ::capnp::List<double>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double>> disownParams();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Calculator::Function::CallParams::Pipeline {
public:
  typedef CallParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Calculator::Function::CallResults::Reader {
public:
  typedef CallResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline double getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Calculator::Function::CallResults::Builder {
public:
  typedef CallResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getValue();
  inline void setValue(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Calculator::Function::CallResults::Pipeline {
public:
  typedef CallResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Calculator::EvaluateParams::Reader {
public:
  typedef EvaluateParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasExpression() const;
  inline  ::Calculator::Expression::Reader getExpression() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Calculator::EvaluateParams::Builder {
public:
  typedef EvaluateParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasExpression();
  inline  ::Calculator::Expression::Builder getExpression();
  inline void setExpression( ::Calculator::Expression::Reader value);
  inline  ::Calculator::Expression::Builder initExpression();
  inline void adoptExpression(::capnp::Orphan< ::Calculator::Expression>&& value);
  inline ::capnp::Orphan< ::Calculator::Expression> disownExpression();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Calculator::EvaluateParams::Pipeline {
public:
  typedef EvaluateParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Calculator::Expression::Pipeline getExpression();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Calculator::EvaluateResults::Reader {
public:
  typedef EvaluateResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasValue() const;
#if !CAPNP_LITE
  inline  ::Calculator::Value::Client getValue() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Calculator::EvaluateResults::Builder {
public:
  typedef EvaluateResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasValue();
#if !CAPNP_LITE
  inline  ::Calculator::Value::Client getValue();
  inline void setValue( ::Calculator::Value::Client&& value);
  inline void setValue( ::Calculator::Value::Client& value);
  inline void adoptValue(::capnp::Orphan< ::Calculator::Value>&& value);
  inline ::capnp::Orphan< ::Calculator::Value> disownValue();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Calculator::EvaluateResults::Pipeline {
public:
  typedef EvaluateResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Calculator::Value::Client getValue();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Calculator::DefFunctionParams::Reader {
public:
  typedef DefFunctionParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getParamCount() const;

  inline bool hasBody() const;
  inline  ::Calculator::Expression::Reader getBody() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Calculator::DefFunctionParams::Builder {
public:
  typedef DefFunctionParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getParamCount();
  inline void setParamCount( ::int32_t value);

  inline bool hasBody();
  inline  ::Calculator::Expression::Builder getBody();
  inline void setBody( ::Calculator::Expression::Reader value);
  inline  ::Calculator::Expression::Builder initBody();
  inline void adoptBody(::capnp::Orphan< ::Calculator::Expression>&& value);
  inline ::capnp::Orphan< ::Calculator::Expression> disownBody();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Calculator::DefFunctionParams::Pipeline {
public:
  typedef DefFunctionParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Calculator::Expression::Pipeline getBody();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Calculator::DefFunctionResults::Reader {
public:
  typedef DefFunctionResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasFunc() const;
#if !CAPNP_LITE
  inline  ::Calculator::Function::Client getFunc() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Calculator::DefFunctionResults::Builder {
public:
  typedef DefFunctionResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasFunc();
#if !CAPNP_LITE
  inline  ::Calculator::Function::Client getFunc();
  inline void setFunc( ::Calculator::Function::Client&& value);
  inline void setFunc( ::Calculator::Function::Client& value);
  inline void adoptFunc(::capnp::Orphan< ::Calculator::Function>&& value);
  inline ::capnp::Orphan< ::Calculator::Function> disownFunc();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Calculator::DefFunctionResults::Pipeline {
public:
  typedef DefFunctionResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Calculator::Function::Client getFunc();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Calculator::GetOperatorParams::Reader {
public:
  typedef GetOperatorParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::Calculator::Operator getOp() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Calculator::GetOperatorParams::Builder {
public:
  typedef GetOperatorParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::Calculator::Operator getOp();
  inline void setOp( ::Calculator::Operator value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Calculator::GetOperatorParams::Pipeline {
public:
  typedef GetOperatorParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Calculator::GetOperatorResults::Reader {
public:
  typedef GetOperatorResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasFunc() const;
#if !CAPNP_LITE
  inline  ::Calculator::Function::Client getFunc() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Calculator::GetOperatorResults::Builder {
public:
  typedef GetOperatorResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasFunc();
#if !CAPNP_LITE
  inline  ::Calculator::Function::Client getFunc();
  inline void setFunc( ::Calculator::Function::Client&& value);
  inline void setFunc( ::Calculator::Function::Client& value);
  inline void adoptFunc(::capnp::Orphan< ::Calculator::Function>&& value);
  inline ::capnp::Orphan< ::Calculator::Function> disownFunc();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Calculator::GetOperatorResults::Pipeline {
public:
  typedef GetOperatorResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Calculator::Function::Client getFunc();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

#if !CAPNP_LITE
inline Calculator::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Calculator::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Calculator::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Calculator::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Calculator::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::Calculator::Client& Calculator::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::Calculator::Client& Calculator::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::Calculator::Expression::Which Calculator::Expression::Reader::which() const {
  return _reader.getDataField<Which>(4 * ::capnp::ELEMENTS);
}
inline  ::Calculator::Expression::Which Calculator::Expression::Builder::which() {
  return _builder.getDataField<Which>(4 * ::capnp::ELEMENTS);
}

inline bool Calculator::Expression::Reader::isLiteral() const {
  return which() == Calculator::Expression::LITERAL;
}
inline bool Calculator::Expression::Builder::isLiteral() {
  return which() == Calculator::Expression::LITERAL;
}
inline double Calculator::Expression::Reader::getLiteral() const {
  KJ_IREQUIRE(which() == Calculator::Expression::LITERAL,
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}

inline double Calculator::Expression::Builder::getLiteral() {
  KJ_IREQUIRE(which() == Calculator::Expression::LITERAL,
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}
inline void Calculator::Expression::Builder::setLiteral(double value) {
  _builder.setDataField<Calculator::Expression::Which>(
      4 * ::capnp::ELEMENTS, Calculator::Expression::LITERAL);
  _builder.setDataField<double>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool Calculator::Expression::Reader::isPreviousResult() const {
  return which() == Calculator::Expression::PREVIOUS_RESULT;
}
inline bool Calculator::Expression::Builder::isPreviousResult() {
  return which() == Calculator::Expression::PREVIOUS_RESULT;
}
inline bool Calculator::Expression::Reader::hasPreviousResult() const {
  if (which() != Calculator::Expression::PREVIOUS_RESULT) return false;
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Calculator::Expression::Builder::hasPreviousResult() {
  if (which() != Calculator::Expression::PREVIOUS_RESULT) return false;
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::Calculator::Value::Client Calculator::Expression::Reader::getPreviousResult() const {
  KJ_IREQUIRE(which() == Calculator::Expression::PREVIOUS_RESULT,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Calculator::Value>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Calculator::Value::Client Calculator::Expression::Builder::getPreviousResult() {
  KJ_IREQUIRE(which() == Calculator::Expression::PREVIOUS_RESULT,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Calculator::Value>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Calculator::Expression::Builder::setPreviousResult( ::Calculator::Value::Client&& cap) {
  _builder.setDataField<Calculator::Expression::Which>(
      4 * ::capnp::ELEMENTS, Calculator::Expression::PREVIOUS_RESULT);
  ::capnp::_::PointerHelpers< ::Calculator::Value>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(cap));
}
inline void Calculator::Expression::Builder::setPreviousResult( ::Calculator::Value::Client& cap) {
  _builder.setDataField<Calculator::Expression::Which>(
      4 * ::capnp::ELEMENTS, Calculator::Expression::PREVIOUS_RESULT);
  ::capnp::_::PointerHelpers< ::Calculator::Value>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), cap);
}
inline void Calculator::Expression::Builder::adoptPreviousResult(
    ::capnp::Orphan< ::Calculator::Value>&& value) {
  _builder.setDataField<Calculator::Expression::Which>(
      4 * ::capnp::ELEMENTS, Calculator::Expression::PREVIOUS_RESULT);
  ::capnp::_::PointerHelpers< ::Calculator::Value>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Calculator::Value> Calculator::Expression::Builder::disownPreviousResult() {
  KJ_IREQUIRE(which() == Calculator::Expression::PREVIOUS_RESULT,
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Calculator::Value>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Calculator::Expression::Reader::isParameter() const {
  return which() == Calculator::Expression::PARAMETER;
}
inline bool Calculator::Expression::Builder::isParameter() {
  return which() == Calculator::Expression::PARAMETER;
}
inline  ::uint32_t Calculator::Expression::Reader::getParameter() const {
  KJ_IREQUIRE(which() == Calculator::Expression::PARAMETER,
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Calculator::Expression::Builder::getParameter() {
  KJ_IREQUIRE(which() == Calculator::Expression::PARAMETER,
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Calculator::Expression::Builder::setParameter( ::uint32_t value) {
  _builder.setDataField<Calculator::Expression::Which>(
      4 * ::capnp::ELEMENTS, Calculator::Expression::PARAMETER);
  _builder.setDataField< ::uint32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool Calculator::Expression::Reader::isCall() const {
  return which() == Calculator::Expression::CALL;
}
inline bool Calculator::Expression::Builder::isCall() {
  return which() == Calculator::Expression::CALL;
}
inline Calculator::Expression::Call::Reader Calculator::Expression::Reader::getCall() const {
  KJ_IREQUIRE(which() == Calculator::Expression::CALL,
              "Must check which() before get()ing a union member.");
  return Calculator::Expression::Call::Reader(_reader);
}
inline Calculator::Expression::Call::Builder Calculator::Expression::Builder::getCall() {
  KJ_IREQUIRE(which() == Calculator::Expression::CALL,
              "Must check which() before get()ing a union member.");
  return Calculator::Expression::Call::Builder(_builder);
}
inline Calculator::Expression::Call::Builder Calculator::Expression::Builder::initCall() {
  _builder.setDataField<Calculator::Expression::Which>(
      4 * ::capnp::ELEMENTS, Calculator::Expression::CALL);
  _builder.getPointerField(0 * ::capnp::POINTERS).clear();
  _builder.getPointerField(1 * ::capnp::POINTERS).clear();
  return Calculator::Expression::Call::Builder(_builder);
}
inline bool Calculator::Expression::Call::Reader::hasFunction() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Calculator::Expression::Call::Builder::hasFunction() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::Calculator::Function::Client Calculator::Expression::Call::Reader::getFunction() const {
  return ::capnp::_::PointerHelpers< ::Calculator::Function>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Calculator::Function::Client Calculator::Expression::Call::Builder::getFunction() {
  return ::capnp::_::PointerHelpers< ::Calculator::Function>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Calculator::Function::Client Calculator::Expression::Call::Pipeline::getFunction() {
  return  ::Calculator::Function::Client(_typeless.getPointerField(0).asCap());
}
inline void Calculator::Expression::Call::Builder::setFunction( ::Calculator::Function::Client&& cap) {
  ::capnp::_::PointerHelpers< ::Calculator::Function>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(cap));
}
inline void Calculator::Expression::Call::Builder::setFunction( ::Calculator::Function::Client& cap) {
  ::capnp::_::PointerHelpers< ::Calculator::Function>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), cap);
}
inline void Calculator::Expression::Call::Builder::adoptFunction(
    ::capnp::Orphan< ::Calculator::Function>&& value) {
  ::capnp::_::PointerHelpers< ::Calculator::Function>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Calculator::Function> Calculator::Expression::Call::Builder::disownFunction() {
  return ::capnp::_::PointerHelpers< ::Calculator::Function>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Calculator::Expression::Call::Reader::hasParams() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool Calculator::Expression::Call::Builder::hasParams() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Calculator::Expression>::Reader Calculator::Expression::Call::Reader::getParams() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Calculator::Expression>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Calculator::Expression>::Builder Calculator::Expression::Call::Builder::getParams() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Calculator::Expression>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void Calculator::Expression::Call::Builder::setParams( ::capnp::List< ::Calculator::Expression>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Calculator::Expression>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Calculator::Expression>::Builder Calculator::Expression::Call::Builder::initParams(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Calculator::Expression>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void Calculator::Expression::Call::Builder::adoptParams(
    ::capnp::Orphan< ::capnp::List< ::Calculator::Expression>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Calculator::Expression>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Calculator::Expression>> Calculator::Expression::Call::Builder::disownParams() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Calculator::Expression>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline Calculator::Value::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Calculator::Value::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Calculator::Value::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Calculator::Value::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Calculator::Value::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::Calculator::Value::Client& Calculator::Value::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::Calculator::Value::Client& Calculator::Value::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline double Calculator::Value::ReadResults::Reader::getValue() const {
  return _reader.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}

inline double Calculator::Value::ReadResults::Builder::getValue() {
  return _builder.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}
inline void Calculator::Value::ReadResults::Builder::setValue(double value) {
  _builder.setDataField<double>(
      0 * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline Calculator::Function::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Calculator::Function::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Calculator::Function::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Calculator::Function::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Calculator::Function::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::Calculator::Function::Client& Calculator::Function::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::Calculator::Function::Client& Calculator::Function::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Calculator::Function::CallParams::Reader::hasParams() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Calculator::Function::CallParams::Builder::hasParams() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double>::Reader Calculator::Function::CallParams::Reader::getParams() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List<double>::Builder Calculator::Function::CallParams::Builder::getParams() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Calculator::Function::CallParams::Builder::setParams( ::capnp::List<double>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline void Calculator::Function::CallParams::Builder::setParams(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double>::Builder Calculator::Function::CallParams::Builder::initParams(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void Calculator::Function::CallParams::Builder::adoptParams(
    ::capnp::Orphan< ::capnp::List<double>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double>> Calculator::Function::CallParams::Builder::disownParams() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline double Calculator::Function::CallResults::Reader::getValue() const {
  return _reader.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}

inline double Calculator::Function::CallResults::Builder::getValue() {
  return _builder.getDataField<double>(
      0 * ::capnp::ELEMENTS);
}
inline void Calculator::Function::CallResults::Builder::setValue(double value) {
  _builder.setDataField<double>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool Calculator::EvaluateParams::Reader::hasExpression() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Calculator::EvaluateParams::Builder::hasExpression() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::Calculator::Expression::Reader Calculator::EvaluateParams::Reader::getExpression() const {
  return ::capnp::_::PointerHelpers< ::Calculator::Expression>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Calculator::Expression::Builder Calculator::EvaluateParams::Builder::getExpression() {
  return ::capnp::_::PointerHelpers< ::Calculator::Expression>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Calculator::Expression::Pipeline Calculator::EvaluateParams::Pipeline::getExpression() {
  return  ::Calculator::Expression::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Calculator::EvaluateParams::Builder::setExpression( ::Calculator::Expression::Reader value) {
  ::capnp::_::PointerHelpers< ::Calculator::Expression>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::Calculator::Expression::Builder Calculator::EvaluateParams::Builder::initExpression() {
  return ::capnp::_::PointerHelpers< ::Calculator::Expression>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Calculator::EvaluateParams::Builder::adoptExpression(
    ::capnp::Orphan< ::Calculator::Expression>&& value) {
  ::capnp::_::PointerHelpers< ::Calculator::Expression>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Calculator::Expression> Calculator::EvaluateParams::Builder::disownExpression() {
  return ::capnp::_::PointerHelpers< ::Calculator::Expression>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool Calculator::EvaluateResults::Reader::hasValue() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Calculator::EvaluateResults::Builder::hasValue() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::Calculator::Value::Client Calculator::EvaluateResults::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::Calculator::Value>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Calculator::Value::Client Calculator::EvaluateResults::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::Calculator::Value>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Calculator::Value::Client Calculator::EvaluateResults::Pipeline::getValue() {
  return  ::Calculator::Value::Client(_typeless.getPointerField(0).asCap());
}
inline void Calculator::EvaluateResults::Builder::setValue( ::Calculator::Value::Client&& cap) {
  ::capnp::_::PointerHelpers< ::Calculator::Value>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(cap));
}
inline void Calculator::EvaluateResults::Builder::setValue( ::Calculator::Value::Client& cap) {
  ::capnp::_::PointerHelpers< ::Calculator::Value>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), cap);
}
inline void Calculator::EvaluateResults::Builder::adoptValue(
    ::capnp::Orphan< ::Calculator::Value>&& value) {
  ::capnp::_::PointerHelpers< ::Calculator::Value>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Calculator::Value> Calculator::EvaluateResults::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::Calculator::Value>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::int32_t Calculator::DefFunctionParams::Reader::getParamCount() const {
  return _reader.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int32_t Calculator::DefFunctionParams::Builder::getParamCount() {
  return _builder.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Calculator::DefFunctionParams::Builder::setParamCount( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool Calculator::DefFunctionParams::Reader::hasBody() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Calculator::DefFunctionParams::Builder::hasBody() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::Calculator::Expression::Reader Calculator::DefFunctionParams::Reader::getBody() const {
  return ::capnp::_::PointerHelpers< ::Calculator::Expression>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Calculator::Expression::Builder Calculator::DefFunctionParams::Builder::getBody() {
  return ::capnp::_::PointerHelpers< ::Calculator::Expression>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Calculator::Expression::Pipeline Calculator::DefFunctionParams::Pipeline::getBody() {
  return  ::Calculator::Expression::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Calculator::DefFunctionParams::Builder::setBody( ::Calculator::Expression::Reader value) {
  ::capnp::_::PointerHelpers< ::Calculator::Expression>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::Calculator::Expression::Builder Calculator::DefFunctionParams::Builder::initBody() {
  return ::capnp::_::PointerHelpers< ::Calculator::Expression>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Calculator::DefFunctionParams::Builder::adoptBody(
    ::capnp::Orphan< ::Calculator::Expression>&& value) {
  ::capnp::_::PointerHelpers< ::Calculator::Expression>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Calculator::Expression> Calculator::DefFunctionParams::Builder::disownBody() {
  return ::capnp::_::PointerHelpers< ::Calculator::Expression>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool Calculator::DefFunctionResults::Reader::hasFunc() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Calculator::DefFunctionResults::Builder::hasFunc() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::Calculator::Function::Client Calculator::DefFunctionResults::Reader::getFunc() const {
  return ::capnp::_::PointerHelpers< ::Calculator::Function>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Calculator::Function::Client Calculator::DefFunctionResults::Builder::getFunc() {
  return ::capnp::_::PointerHelpers< ::Calculator::Function>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Calculator::Function::Client Calculator::DefFunctionResults::Pipeline::getFunc() {
  return  ::Calculator::Function::Client(_typeless.getPointerField(0).asCap());
}
inline void Calculator::DefFunctionResults::Builder::setFunc( ::Calculator::Function::Client&& cap) {
  ::capnp::_::PointerHelpers< ::Calculator::Function>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(cap));
}
inline void Calculator::DefFunctionResults::Builder::setFunc( ::Calculator::Function::Client& cap) {
  ::capnp::_::PointerHelpers< ::Calculator::Function>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), cap);
}
inline void Calculator::DefFunctionResults::Builder::adoptFunc(
    ::capnp::Orphan< ::Calculator::Function>&& value) {
  ::capnp::_::PointerHelpers< ::Calculator::Function>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Calculator::Function> Calculator::DefFunctionResults::Builder::disownFunc() {
  return ::capnp::_::PointerHelpers< ::Calculator::Function>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::Calculator::Operator Calculator::GetOperatorParams::Reader::getOp() const {
  return _reader.getDataField< ::Calculator::Operator>(
      0 * ::capnp::ELEMENTS);
}

inline  ::Calculator::Operator Calculator::GetOperatorParams::Builder::getOp() {
  return _builder.getDataField< ::Calculator::Operator>(
      0 * ::capnp::ELEMENTS);
}
inline void Calculator::GetOperatorParams::Builder::setOp( ::Calculator::Operator value) {
  _builder.setDataField< ::Calculator::Operator>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool Calculator::GetOperatorResults::Reader::hasFunc() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Calculator::GetOperatorResults::Builder::hasFunc() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::Calculator::Function::Client Calculator::GetOperatorResults::Reader::getFunc() const {
  return ::capnp::_::PointerHelpers< ::Calculator::Function>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Calculator::Function::Client Calculator::GetOperatorResults::Builder::getFunc() {
  return ::capnp::_::PointerHelpers< ::Calculator::Function>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::Calculator::Function::Client Calculator::GetOperatorResults::Pipeline::getFunc() {
  return  ::Calculator::Function::Client(_typeless.getPointerField(0).asCap());
}
inline void Calculator::GetOperatorResults::Builder::setFunc( ::Calculator::Function::Client&& cap) {
  ::capnp::_::PointerHelpers< ::Calculator::Function>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(cap));
}
inline void Calculator::GetOperatorResults::Builder::setFunc( ::Calculator::Function::Client& cap) {
  ::capnp::_::PointerHelpers< ::Calculator::Function>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), cap);
}
inline void Calculator::GetOperatorResults::Builder::adoptFunc(
    ::capnp::Orphan< ::Calculator::Function>&& value) {
  ::capnp::_::PointerHelpers< ::Calculator::Function>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Calculator::Function> Calculator::GetOperatorResults::Builder::disownFunc() {
  return ::capnp::_::PointerHelpers< ::Calculator::Function>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE


#endif  // CAPNP_INCLUDED_85150b117366d14b_
